/**
 * Schema generator script — run via `bun run generate:schemas`
 *
 * Imports AUDIO_NODES and TEXT_OBJECTS, generates schemas via schemasFromNodes(),
 * then emits a TypeScript file with Type.xxx() calls so the schemas can be
 * imported without pulling in the full node class dependency tree.
 */

import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

import { AUDIO_NODES } from '$lib/audio/v2/nodes';
import { TEXT_OBJECTS } from '$lib/objects/v2/nodes';
import { schemasFromNodes } from '$lib/objects/schemas/from-v2-node';
import type {
  ObjectSchema,
  InletSchema,
  OutletSchema,
  MessageSchema
} from '$lib/objects/schemas/types';
import { emitTypeBox } from './emit-typebox';

const __dirname = dirname(fileURLToPath(import.meta.url));
const OUTPUT_PATH = join(__dirname, '../src/lib/generated/object-schemas.generated.ts');

// Generate schemas from node classes using existing utility
const audioSchemas = schemasFromNodes(AUDIO_NODES, 'audio');
const controlSchemas = schemasFromNodes(TEXT_OBJECTS, 'control');
const allSchemas: Record<string, ObjectSchema> = { ...audioSchemas, ...controlSchemas };

// --- Code emitters ---

function emitString(s: string): string {
  return JSON.stringify(s);
}

function emitMessageSchema(msg: MessageSchema): string {
  const parts = [
    `schema: ${emitTypeBox(msg.schema)}`,
    `description: ${emitString(msg.description)}`
  ];

  if (msg.example !== undefined) {
    parts.push(`example: ${emitString(msg.example)}`);
  }

  return `{ ${parts.join(', ')} }`;
}

function emitMessages(messages: MessageSchema[] | undefined): string | null {
  if (!messages || messages.length === 0) return null;
  const items = messages.map((m) => emitMessageSchema(m));
  return `[${items.join(', ')}]`;
}

function emitPort(port: InletSchema | OutletSchema): string {
  const parts: string[] = [`id: ${emitString(port.id)}`];

  if (port.type) parts.push(`type: ${emitString(port.type)}`);
  parts.push(`description: ${emitString(port.description)}`);

  const msgs = emitMessages(port.messages);
  if (msgs) parts.push(`messages: ${msgs}`);

  return `{ ${parts.join(', ')} }`;
}

function emitObjectSchema(schema: ObjectSchema): string {
  const lines: string[] = [];
  lines.push(`    type: ${emitString(schema.type)},`);
  lines.push(`    category: ${emitString(schema.category)},`);
  lines.push(`    description: ${emitString(schema.description)},`);

  // Inlets
  if (schema.inlets.length === 0) {
    lines.push('    inlets: [],');
  } else {
    const inletItems = schema.inlets.map((inlet) => `      ${emitPort(inlet)}`).join(',\n');
    lines.push(`    inlets: [\n${inletItems}\n    ],`);
  }

  // Outlets
  if (schema.outlets.length === 0) {
    lines.push('    outlets: [],');
  } else {
    const outletItems = schema.outlets.map((outlet) => `      ${emitPort(outlet)}`).join(',\n');
    lines.push(`    outlets: [\n${outletItems}\n    ],`);
  }

  // Tags
  if (schema.tags && schema.tags.length > 0) {
    lines.push(`    tags: [${schema.tags.map(emitString).join(', ')}]`);
  }

  // hasDynamicOutlets
  if (schema.hasDynamicOutlets) {
    lines.push('    hasDynamicOutlets: true');
  }

  return `  {\n${lines.join('\n')}\n  }`;
}

// --- Build output ---

const sortedEntries = Object.entries(allSchemas).sort(([a], [b]) => a.localeCompare(b));

const schemaEntries = sortedEntries
  .map(([key, schema]) => {
    const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key.replace(/'/g, "\\'")}'`;
    return `  ${safeKey}: ${emitObjectSchema(schema)}`;
  })
  .join(',\n\n');

const output = `/**
 * Auto-generated by scripts/generate-object-schemas.ts
 * Do not edit manually. Run \`bun run generate:schemas\` to regenerate.
 *
 * Contains schemas for ${sortedEntries.length} object types (audio + control).
 */
import { Type } from '@sinclair/typebox';

import type { ObjectSchemaRegistry } from '$lib/objects/schemas/types';

export const generatedObjectSchemas: ObjectSchemaRegistry = {
${schemaEntries}
};
`;

writeFileSync(OUTPUT_PATH, output);
console.log(`[generate-object-schemas] Generated ${sortedEntries.length} schemas → ${OUTPUT_PATH}`);
