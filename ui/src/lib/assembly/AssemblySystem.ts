import type { MachineStatus, Effect, Message } from 'machine';
import type {
	AssemblyWorkerMessage,
	AssemblyWorkerResponse,
	InspectedRegister,
	InspectedMachine,
	MachineConfig
} from '../../workers/assembly/assemblyWorker';
import AssemblyWorker from '../../workers/assembly/assemblyWorker?worker';

/**
 * AssemblySystem provides a clean interface to the VASM (Visual Assembly)
 * virtual machine controller, managing execution of assembly programs
 * within the Patchies environment. Now runs on a web worker to avoid blocking the main thread.
 */
export class AssemblySystem {
	public static instance: AssemblySystem | null = null;
	private worker: Worker;
	private initialized = false;
	private lastId = 1;
	private pendingRequests = new Map<
		string,
		{ resolve: (value: unknown) => void; reject: (error: unknown) => void }
	>();
	public eventBus: EventTarget | null = null;

	private constructor() {
		this.worker = new AssemblyWorker();
		this.worker.addEventListener('message', this.handleWorkerMessage.bind(this));
		this.initialized = true;
		this.eventBus = new EventTarget();
	}

	static getInstance(): AssemblySystem {
		if (!AssemblySystem.instance) {
			AssemblySystem.instance = new AssemblySystem();
		}
		return AssemblySystem.instance;
	}

	private handleWorkerMessage = (event: MessageEvent<AssemblyWorkerResponse>) => {
		const { id, type } = event.data;

		if (id && this.pendingRequests.has(id)) {
			const { resolve, reject } = this.pendingRequests.get(id)!;
			this.pendingRequests.delete(id);

			if (type === 'success') {
				resolve(event.data.result);
			} else if (type === 'error') {
				reject(event.data.error);
			}
		}
	};

	private send<T extends AssemblyWorkerMessage['type']>(
		type: T,
		payload: Omit<Extract<AssemblyWorkerMessage, { type: T }>, 'type' | 'id'>
	): Promise<any> {
		const id = this.getId();

		return new Promise((resolve, reject) => {
			this.pendingRequests.set(id, { resolve, reject });

			this.worker.postMessage({
				type,
				id,
				...payload
			});
		});
	}

	private getId(): string {
		return String(this.lastId++);
	}

	/**
	 * Check if the system is properly initialized
	 */
	isInitialized(): boolean {
		return this.initialized;
	}

	/**
	 * Create a machine with a specific ID
	 */
	async createMachineWithId(id: number): Promise<void> {
		await this.send('createMachineWithId', { machineId: id });
	}

	/**
	 * Remove a machine by ID
	 */
	async removeMachine(id: number): Promise<void> {
		await this.send('removeMachine', { machineId: id });
	}

	/**
	 * Load assembly source code into a machine
	 */
	async loadProgram(machineId: number, source: string): Promise<void> {
		await this.send('loadProgram', { machineId, source });
	}

	/**
	 * Execute a number of instruction cycles
	 */
	async stepMachine(id: number, cycles: number = 1): Promise<void> {
		await this.send('stepMachine', { machineId: id, cycles });
	}

	/**
	 * Check if a machine exists
	 */
	async machineExists(machineId: number): Promise<boolean> {
		return await this.send('machineExists', { machineId });
	}

	/**
	 * Get detailed information about a specific machine
	 */
	async inspectMachine(machineId: number): Promise<InspectedMachine | null> {
		return await this.send('inspectMachine', { machineId });
	}

	/**
	 * Read data from a machine's memory at a specific address
	 */
	async readMemory(machineId: number, address: number, size: number): Promise<number[] | null> {
		return await this.send('readMemory', { machineId, address, size });
	}

	/**
	 * Consume and return effects generated by a machine
	 */
	async consumeMachineEffects(machineId: number): Promise<Effect[]> {
		return await this.send('consumeMachineEffects', { machineId });
	}

	/**
	 * Send a message directly to a machine's inbox
	 */
	async sendMessage(
		machineId: number,
		data: number | number[],
		source: number,
		inlet: number
	): Promise<boolean> {
		return await this.send('sendMessage', { machineId, data, source, inlet });
	}

	/**
	 * Consume all outgoing messages from all machines
	 */
	async consumeMessages(): Promise<Message[]> {
		return await this.send('consumeMessages', {});
	}

	/**
	 * Set machine configuration (delayMs, stepBy, isRunning)
	 */
	async setMachineConfig(machineId: number, config: Partial<MachineConfig>): Promise<void> {
		await this.send('setMachineConfig', { machineId, config });
	}

	/**
	 * Get machine configuration
	 */
	async getMachineConfig(machineId: number): Promise<MachineConfig> {
		return await this.send('getMachineConfig', { machineId });
	}

	/**
	 * Start automatic execution of machine
	 */
	async playMachine(machineId: number): Promise<void> {
		await this.send('playMachine', { machineId });
	}

	/**
	 * Pause automatic execution of machine
	 */
	async pauseMachine(machineId: number): Promise<void> {
		await this.send('pauseMachine', { machineId });
	}

	/**
	 * Reset machine to initial state
	 */
	async resetMachine(machineId: number): Promise<void> {
		await this.send('resetMachine', { machineId });
	}

	/**
	 * Dispose of the system and free resources
	 */
	dispose(): void {
		if (this.worker) {
			this.worker.terminate();
		}
		this.pendingRequests.clear();
		this.initialized = false;
	}
}

/**
 * Get the global AssemblySystem instance
 */
export function getAssemblySystem(): AssemblySystem {
	return AssemblySystem.getInstance();
}

/**
 * Dispose of the global AssemblySystem instance
 */
export function disposeAssemblySystem(): void {
	const instance = AssemblySystem.getInstance();
	instance.dispose();
	AssemblySystem.instance = null;
}

export type { MachineStatus, Effect, Message, InspectedMachine, InspectedRegister, MachineConfig };
