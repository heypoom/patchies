import { Controller, type MachineStatus, type Effect, type Message } from 'machine';

// Define types that are serialized from Rust but not exported in TypeScript
export interface InspectedRegister {
	pc: number;
	sp: number;
	fp: number;
}

export interface InspectedMachine {
	effects: Effect[];
	registers: InspectedRegister;
	inbox_size: number;
	outbox_size: number;
	status: MachineStatus;
}

/**
 * AssemblySystem provides a clean interface to the VASM (Visual Assembly)
 * virtual machine controller, managing execution of assembly programs
 * within the Patchies environment.
 */
export class AssemblySystem {
	private controller: Controller;
	private initialized = false;

	constructor() {
		this.controller = Controller.create();
		this.initialized = true;
	}

	/**
	 * Check if the system is properly initialized
	 */
	isInitialized(): boolean {
		return this.initialized;
	}

	/**
	 * Create a new virtual machine and return its ID
	 */
	createMachine(): number {
		return this.controller.add_machine();
	}

	/**
	 * Create a machine with a specific ID
	 */
	createMachineWithId(id: number): void {
		this.controller.add_machine_with_id(id);
	}

	/**
	 * Remove a machine by ID
	 */
	removeMachine(id: number): void {
		this.controller.remove_machine(id);
	}

	/**
	 * Load assembly source code into a machine
	 */
	loadProgram(machineId: number, source: string): void {
		try {
			this.controller.load(machineId, source);
		} catch (error) {
			console.error(`Failed to load program into machine ${machineId}:`, error);
			throw error;
		}
	}

	/**
	 * Mark all machines as ready for execution
	 */
	ready(): void {
		this.controller.ready();
	}

	/**
	 * Execute a number of instruction cycles
	 */
	step(cycles: number = 1): void {
		try {
			this.controller.step(cycles);
		} catch (error) {
			console.error('Failed to execute step:', error);
			throw error;
		}
	}

	/**
	 * Get the status of all machines
	 */
	getStatuses(): Record<string, MachineStatus> {
		return this.controller.statuses();
	}

	/**
	 * Check if all machines have halted
	 */
	isHalted(): boolean {
		return this.controller.is_halted();
	}

	/**
	 * Get detailed information about a specific machine
	 */
	inspectMachine(machineId: number): InspectedMachine | null {
		try {
			const result = this.controller.inspect_machine(machineId);
			return result === null ? null : result;
		} catch (error) {
			console.error(`Failed to inspect machine ${machineId}:`, error);
			return null;
		}
	}

	/**
	 * Read code from a machine's memory
	 */
	readCode(machineId: number, size: number): number[] | null {
		try {
			const result = this.controller.read_code(machineId, size);
			return result === null ? null : result;
		} catch (error) {
			console.error(`Failed to read code from machine ${machineId}:`, error);
			return null;
		}
	}

	/**
	 * Read data from a machine's memory at a specific address
	 */
	readMemory(machineId: number, address: number, size: number): number[] | null {
		try {
			const result = this.controller.read_mem(machineId, address, size);
			return result === null ? null : result;
		} catch (error) {
			console.error(`Failed to read memory from machine ${machineId}:`, error);
			return null;
		}
	}

	/**
	 * Read data from a machine's stack
	 */
	readStack(machineId: number, size: number): number[] | null {
		try {
			const result = this.controller.read_stack(machineId, size);
			return result === null ? null : result;
		} catch (error) {
			console.error(`Failed to read stack from machine ${machineId}:`, error);
			return null;
		}
	}

	/**
	 * Write data to a machine's memory at a specific address
	 */
	writeMemory(machineId: number, address: number, data: number[]): boolean {
		try {
			const uint16Array = new Uint16Array(data);
			return this.controller.set_mem(machineId, address, uint16Array);
		} catch (error) {
			console.error(`Failed to write memory to machine ${machineId}:`, error);
			return false;
		}
	}

	/**
	 * Wake a sleeping machine
	 */
	wakeMachine(machineId: number): void {
		this.controller.wake(machineId);
	}

	/**
	 * Consume and return effects generated by a machine
	 */
	consumeMachineEffects(machineId: number): Effect[] {
		try {
			return this.controller.consume_machine_side_effects(machineId);
		} catch (error) {
			console.error(`Failed to consume effects from machine ${machineId}:`, error);
			return [];
		}
	}

	/**
	 * Send a message directly to a machine's inbox
	 */
	sendMessage(machineId: number, message: Message): boolean {
		try {
			return this.controller.send_message_to_machine(machineId, message);
		} catch (error) {
			console.error(`Failed to send message to machine ${machineId}:`, error);
			return false;
		}
	}

	/**
	 * Consume all outgoing messages from all machines
	 */
	consumeMessages(): Message[] {
		try {
			return this.controller.consume_messages();
		} catch (error) {
			console.error('Failed to consume messages:', error);
			return [];
		}
	}

	/**
	 * Route messages between machines
	 */
	routeMessages(): void {
		try {
			this.controller.route_messages();
		} catch (error) {
			console.error('Failed to route messages:', error);
		}
	}

	/**
	 * Enable or disable the await watchdog
	 */
	setAwaitWatchdog(enabled: boolean): void {
		this.controller.set_await_watchdog(enabled);
	}

	/**
	 * Clear all machines and reset the system
	 */
	clear(): void {
		this.controller.clear();
	}

	/**
	 * Get a full serialized state of the system (for debugging)
	 */
	getFullState(): unknown {
		try {
			return this.controller.full_serialize_sequencer_state();
		} catch (error) {
			console.error('Failed to serialize full state:', error);
			return null;
		}
	}

	/**
	 * Get a partial serialized state of the system (excluding buffers)
	 */
	getPartialState(): unknown {
		try {
			return this.controller.partial_serialize_sequencer_state();
		} catch (error) {
			console.error('Failed to serialize partial state:', error);
			return null;
		}
	}

	/**
	 * Dispose of the system and free resources
	 */
	dispose(): void {
		if (this.controller) {
			this.controller.free();
		}
		this.initialized = false;
	}
}

// Singleton instance for global access
let assemblySystem: AssemblySystem | null = null;

/**
 * Get the global AssemblySystem instance
 */
export function getAssemblySystem(): AssemblySystem {
	if (!assemblySystem) {
		assemblySystem = new AssemblySystem();
	}
	return assemblySystem;
}

/**
 * Dispose of the global AssemblySystem instance
 */
export function disposeAssemblySystem(): void {
	if (assemblySystem) {
		assemblySystem.dispose();
		assemblySystem = null;
	}
}

export type { MachineStatus, Effect, Message };
