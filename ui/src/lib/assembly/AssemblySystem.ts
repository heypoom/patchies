import type { MachineStatus, Effect, Message } from 'machine';
import type {
	AssemblyWorkerMessage,
	AssemblyWorkerResponse,
	InspectedRegister,
	InspectedMachine,
	MachineConfig
} from '../../workers/assembly/assemblyWorker';
import AssemblyWorker from '../../workers/assembly/assemblyWorker?worker';
import { memoryRegionStore, type MemoryRegion } from './memoryRegionStore';

/**
 * AssemblySystem provides a clean interface to the VASM (Visual Assembly)
 * virtual machine controller, managing execution of assembly programs
 * within the Patchies environment. Now runs on a web worker to avoid blocking the main thread.
 */
export class AssemblySystem {
	public static instance: AssemblySystem | null = null;
	private worker: Worker;
	private initialized = false;
	private lastId = 1;
	private pendingRequests = new Map<
		string,
		{ resolve: (value: unknown) => void; reject: (error: unknown) => void }
	>();
	public eventBus: EventTarget | null = null;
	public highlighters = new Map<number, (lineNo: number) => void>();
	private highlightMaps = new Map<number, Map<number, number>>();
	private machineColors = new Map<number, number>();

	private constructor() {
		this.worker = new AssemblyWorker();
		this.worker.addEventListener('message', this.handleWorkerMessage.bind(this));
		this.initialized = true;
		this.eventBus = new EventTarget();
	}

	static getInstance(): AssemblySystem {
		if (!AssemblySystem.instance) {
			AssemblySystem.instance = new AssemblySystem();
		}
		return AssemblySystem.instance;
	}

	private handleWorkerMessage = (event: MessageEvent<AssemblyWorkerResponse>) => {
		const { id, type } = event.data;

		if (id && this.pendingRequests.has(id)) {
			const { resolve, reject } = this.pendingRequests.get(id)!;
			this.pendingRequests.delete(id);

			if (type === 'success') {
				resolve(event.data.result);
			} else if (type === 'error') {
				reject(event.data.error);
			}
		}
	};

	send<T extends AssemblyWorkerMessage['type']>(
		type: T,
		payload: Omit<Extract<AssemblyWorkerMessage, { type: T }>, 'type' | 'id'>
	): Promise<any> {
		const id = this.getId();

		return new Promise((resolve, reject) => {
			this.pendingRequests.set(id, { resolve, reject });

			this.worker.postMessage({
				type,
				id,
				...payload
			});
		});
	}

	private getId(): string {
		return String(this.lastId++);
	}

	/**
	 * Check if the system is properly initialized
	 */
	isInitialized(): boolean {
		return this.initialized;
	}

	/**
	 * Create a machine with a specific ID
	 */
	async createMachineWithId(id: number): Promise<void> {
		await this.send('createMachineWithId', { machineId: id });
	}

	/**
	 * Remove a machine by ID
	 */
	async removeMachine(id: number): Promise<void> {
		await this.send('removeMachine', { machineId: id });
		// Clean up highlight mapping
		this.highlightMaps.delete(id);
		// Clean up memory regions
		this.clearMemoryRegions(id);
		// Clean up machine color
		this.machineColors.delete(id);
	}

	/**
	 * Load assembly source code into a machine
	 */
	async loadProgram(machineId: number, source: string): Promise<void> {
		await this.send('loadProgram', { machineId, source });
		// Create highlight mapping for this machine's source code
		this.highlightMaps.set(machineId, this.createHighlightMap(source));
	}

	/**
	 * Execute a number of instruction cycles
	 */
	async stepMachine(id: number, cycles: number = 1): Promise<void> {
		await this.send('stepMachine', { machineId: id, cycles });
	}

	/**
	 * Check if a machine exists
	 */
	async machineExists(machineId: number): Promise<boolean> {
		return await this.send('machineExists', { machineId });
	}

	/**
	 * Get detailed information about a specific machine
	 */
	async inspectMachine(machineId: number): Promise<InspectedMachine | null> {
		return await this.send('inspectMachine', { machineId });
	}

	/**
	 * Read data from a machine's memory at a specific address
	 */
	async readMemory(machineId: number, address: number, size: number): Promise<number[] | null> {
		return await this.send('readMemory', { machineId, address, size });
	}

	/**
	 * Consume and return effects generated by a machine
	 */
	async consumeMachineEffects(machineId: number): Promise<Effect[]> {
		return await this.send('consumeMachineEffects', { machineId });
	}

	/**
	 * Send a message directly to a machine's inbox
	 */
	async sendMessage(
		machineId: number,
		data: number | number[],
		source: number,
		inlet: number
	): Promise<boolean> {
		return await this.send('sendMessage', { machineId, data, source, inlet });
	}

	/**
	 * Consume all outgoing messages from all machines
	 */
	async consumeMessages(machineId: number): Promise<Message[]> {
		return await this.send('consumeMessages', { machineId });
	}

	/**
	 * Set machine configuration (delayMs, stepBy, isRunning)
	 */
	async setMachineConfig(machineId: number, config: Partial<MachineConfig>): Promise<void> {
		await this.send('setMachineConfig', { machineId, config });
	}

	/**
	 * Get machine configuration
	 */
	async getMachineConfig(machineId: number): Promise<MachineConfig> {
		return await this.send('getMachineConfig', { machineId });
	}

	/**
	 * Start automatic execution of machine
	 */
	async playMachine(machineId: number): Promise<void> {
		await this.send('playMachine', { machineId });
	}

	/**
	 * Pause automatic execution of machine
	 */
	async pauseMachine(machineId: number): Promise<void> {
		await this.send('pauseMachine', { machineId });
	}

	async resetMachine(machineId: number): Promise<void> {
		await this.send('resetMachine', { machineId });
	}

	/**
	 * Set a memory value with color region tracking
	 */
	async setMemoryValue(
		machineId: number,
		address: number,
		value: number | number[],
		color?: number
	): Promise<void> {
		// Set the memory value (this would need to be implemented in the worker)
		const values = Array.isArray(value) ? value : [value];

		// For now, we'll track the region in our store
		if (color !== undefined) {
			// Check if there's already a region at this exact address and size
			const existingRegions = memoryRegionStore.getRegionsForMachine(machineId);
			const existingRegion = existingRegions.find(r => r.offset === address && r.size === values.length);

			if (existingRegion) {
				// Update existing region with new color
				memoryRegionStore.setRegion(machineId, {
					id: existingRegion.id,
					offset: address,
					size: values.length,
					color
				});
			} else {
				// Create new region
				const regionId = Date.now(); // Simple ID generation
				memoryRegionStore.setRegion(machineId, {
					id: regionId,
					offset: address,
					size: values.length,
					color
				});
			}
		}

		// TODO: Implement actual memory setting in the worker
		console.log(`Setting memory at ${address} with values:`, values, 'color:', color);
	}

	/**
	 * Get memory regions for a machine
	 */
	getMemoryRegions(machineId: number): MemoryRegion[] {
		return memoryRegionStore.getRegionsForMachine(machineId);
	}

	/**
	 * Clear memory regions for a machine
	 */
	clearMemoryRegions(machineId: number): void {
		memoryRegionStore.clearMachine(machineId);
	}

	/**
	 * Set the default color for a machine
	 */
	setMachineColor(machineId: number, color: number): void {
		this.machineColors.set(machineId, color);
	}

	/**
	 * Get the default color for a machine
	 */
	getMachineColor(machineId: number): number {
		return this.machineColors.get(machineId) ?? 0;
	}

	/**
	 * Register a line highlighter callback for a machine
	 */
	registerHighlighter(machineId: number, callback: (lineNo: number) => void): void {
		this.highlighters.set(machineId, callback);
	}

	/**
	 * Unregister a line highlighter for a machine
	 */
	unregisterHighlighter(machineId: number): void {
		this.highlighters.delete(machineId);
	}

	/**
	 * Create a mapping from program counter to source line numbers
	 */
	private createHighlightMap(source: string): Map<number, number> {
		const lines = source.split('\n');
		const mapping = new Map<number, number>();

		let pc = 0;
		let linePos = 0;

		for (const line of lines) {
			const [opcode, ...args] = line.trim().split(' ');
			linePos++;

			// Skip comments, labels and directives
			if (line.length === 0) continue;
			if (opcode.endsWith(':')) continue;
			if (opcode.startsWith('//')) continue;
			if (opcode.startsWith(';')) continue;
			if (opcode.startsWith('.')) continue;

			pc++;

			for (const arg of args) {
				if (arg.trim().length === 0) continue;
				if (arg.startsWith(';')) break;

				pc++;
			}

			mapping.set(pc, linePos - 1);
		}

		return mapping;
	}

	/**
	 * Trigger line highlighting for a specific machine using PC
	 */
	highlightLineFromPC(machineId: number, pc: number): void {
		const highlighter = this.highlighters.get(machineId);
		const mapping = this.highlightMaps.get(machineId);

		if (highlighter && mapping) {
			const lineNo = (mapping.get(pc) ?? 0) + 1;
			highlighter(lineNo);
		}
	}

	/**
	 * Trigger line highlighting for a specific machine
	 */
	highlightLine(machineId: number, lineNo: number): void {
		const highlighter = this.highlighters.get(machineId);
		if (highlighter) {
			highlighter(lineNo);
		}
	}

	/**
	 * Dispose of the system and free resources
	 */
	dispose(): void {
		if (this.worker) {
			this.worker.terminate();
		}
		this.pendingRequests.clear();
		this.highlighters.clear();
		this.highlightMaps.clear();
		this.machineColors.clear();
		this.initialized = false;
	}
}

/**
 * Get the global AssemblySystem instance
 */
export function getAssemblySystem(): AssemblySystem {
	return AssemblySystem.getInstance();
}

/**
 * Dispose of the global AssemblySystem instance
 */
export function disposeAssemblySystem(): void {
	const instance = AssemblySystem.getInstance();
	instance.dispose();
	AssemblySystem.instance = null;
}

/**
 * Global API for assembly code to set colored memory values
 * This function can be called during assembly execution
 */
export function asmValue(
	machineId: number,
	address: number,
	value: number | number[],
	color?: number
): void {
	const system = AssemblySystem.getInstance();
	// Use machine's default color if no color is specified
	const finalColor = color !== undefined ? color : system.getMachineColor(machineId);
	system.setMemoryValue(machineId, address, value, finalColor);
}

export type { MachineStatus, Effect, Message, InspectedMachine, InspectedRegister, MachineConfig };
